import{_ as e,o as s,c as a,Q as o}from"./chunks/framework.4636910e.js";const f=JSON.parse('{"title":"Custom Constraints","description":"","frontmatter":{},"headers":[],"relativePath":"docs/language/constraints/custom-constraints.md","filePath":"docs/language/constraints/custom-constraints.md"}'),t={name:"docs/language/constraints/custom-constraints.md"},n=o(`<h1 id="custom-constraints" tabindex="-1">Custom Constraints <a class="header-anchor" href="#custom-constraints" aria-label="Permalink to &quot;Custom Constraints&quot;">​</a></h1><p>LMQL&#39;s constraint language comes with a set of standard operators that can be combined. However, it is also possible to implement custom operations that enable the validation of more complex properties, while maintaining composability with built-in operations.</p><p>This chapter will explain how to implement a custom LMQL operator, using a two custom operators.</p><h2 id="implementing-a-custom-operator" tabindex="-1">Implementing a Custom Operator <a class="header-anchor" href="#implementing-a-custom-operator" aria-label="Permalink to &quot;Implementing a Custom Operator&quot;">​</a></h2><p>To implement a custom operator, you need to define a class that inherits from <code>lmql.ops.Node</code>. The class must be decorated with the <code>@LMQLOp</code> decorator, which takes the name of the operator as an argument. The operator name can then be used in LMQL queries to refer to the custom operation.</p><p>The basic interface of a custom operator is given by the following methods:</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="hljs"><code><span class="line"><span class="hljs-keyword">from</span> lmql.ops <span class="hljs-keyword">import</span> LMQLOp, Node, InOpStrInSet

<span class="hljs-meta">@LMQLOp(<span class="hljs-params"><span class="hljs-string">&quot;custom_operator&quot;</span></span>)</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomOperator</span>(<span class="hljs-title class_ inherited__">Node</span>):
   <span class="hljs-comment"># provides the value semantics of the operator</span>
   <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, *args, **kwargs</span>):
      ...

   <span class="hljs-comment"># provides a lookahead on the result of the operator (for next-token masking)</span>
   <span class="hljs-keyword">def</span> <span class="hljs-title function_">follow</span>(<span class="hljs-params">self, *args, **kwargs</span>):
      ...
    
   <span class="hljs-comment"># provides the definitiveness of a result (temporary or final)</span>
   <span class="hljs-keyword">def</span> <span class="hljs-title function_">final</span>(<span class="hljs-params">self, *args, **kwargs</span>):
      ...
</span></code></pre></div><ul><li><p><code>forward(self, *args, **kwargs)</code> This method implements the <strong>forward semantics</strong> of you operator, i.e. it determines the result of your operator <code>custom_operator(*args)</code>, i.e. whether something you are validating holds or does not hold for the specified arguments. This method is called for every token in the model output, and thus allows you to implement early stopping during generation.</p></li><li><p><code>follow(self, x, **kwargs)</code>: This method implements the <strong>follow semantics</strong> of your operator, i.e. it provides a lookahead on the result of your operator, given the current value of the specified arguments. The return value of this function is a so-called follow map, that differentiates among the different classes of continuation tokens. This method is called at least once on each token in the model output, to determine the set of allowed next tokens.</p></li><li><p><code>final(self, x, **kwargs)</code>: Lastly\`\`, <code>final</code> implements the <strong>final semantics</strong> of your operator, i.e. it determines whether the result of your operator is final with respect to the current model output. This allows you to differentiate between temporary and final validation results, which is important to prevent early termination in cases of only temporary violations.</p><p>Possible return values are <code>&quot;var&quot;</code> and <code>&quot;fin&quot;</code> for temporary and final (definitive) results, respectively. Going beyond boolean logic, LMQL also supports <code>&quot;inc&quot;</code> and <code>&quot;dec&quot;</code> to indicate monotonically growing and shrinking results, respectively. This is useful character counting, strings and lists. For instance, the input variable <code>x</code> will have either <code>&quot;inc&quot;</code> final-ness, to indicate that it is a monotonically growing string (currently being generated), or <code>&quot;fin&quot;</code> final-ness, to indicate that it has reached its final value (query execution has completed decoding its value).</p></li></ul><p>Depending on your use case, it may suffice to only implement <code>forward</code> (to enable early stopping during generation). However, for full masking support, you also have to implement <code>follow</code> and <code>final</code>.</p><h2 id="example-implementing-a-foo-bar-constraint" tabindex="-1">Example: Implementing a <code>foo</code>-<code>bar</code> Constraint <a class="header-anchor" href="#example-implementing-a-foo-bar-constraint" aria-label="Permalink to &quot;Example: Implementing a \`foo\`-\`bar\` Constraint&quot;">​</a></h2><p>To demonstrate, we implement an operator that forces the model to always generate <code>bar</code> after generating <code>foo</code>. To clarify, the following sequences should be valid and invalid, respectively:</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="hljs"><code><span class="line"><span class="hljs-string">&quot;Hello foo!&quot;</span> <span class="hljs-comment"># invalid</span>
<span class="hljs-string">&quot;Hello foo bar!&quot;</span> <span class="hljs-comment"># valid</span>
<span class="hljs-string">&quot;Hello foo bar foo bar!&quot;</span> <span class="hljs-comment"># valid</span>
<span class="hljs-string">&quot;Hello foo bar foo!&quot;</span> <span class="hljs-comment"># invalid</span>
</span></code></pre></div><p>To enforce this constraint, we implement a custom operator <code>foo_bar</code> as follows:</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="hljs"><code><span class="line"><span class="hljs-keyword">import</span> re
<span class="hljs-keyword">from</span> lmql.ops <span class="hljs-keyword">import</span> LMQLOp, Node, fmap, tset

<span class="hljs-meta">@LMQLOp(<span class="hljs-params"><span class="hljs-string">&quot;foo_bar&quot;</span></span>)</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">FooBar</span>(<span class="hljs-title class_ inherited__">Node</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x, **kwargs</span>):
        <span class="hljs-comment"># no restrictions, if x is not yet generated and there is no &quot;foo&quot; in x</span>
        <span class="hljs-keyword">if</span> x <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> <span class="hljs-string">&quot;foo&quot;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> x:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>

        <span class="hljs-comment"># make sure foo is always followed by &quot; bar&quot;</span>
        bar_segment = x.rsplit(<span class="hljs-string">&quot;foo&quot;</span>,<span class="hljs-number">1</span>)[<span class="hljs-number">1</span>]
        <span class="hljs-keyword">return</span> bar_segment.startswith(<span class="hljs-string">&quot; bar&quot;</span>) <span class="hljs-keyword">or</span> <span class="hljs-built_in">len</span>(bar_segment) == <span class="hljs-number">0</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">follow</span>(<span class="hljs-params">self, x, **kwargs</span>):
        <span class="hljs-comment"># (1) no restrictions, if x is not yet generated</span>
        <span class="hljs-keyword">if</span> x <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
    
        <span class="hljs-comment"># (2) no restrictions, if there is no &quot;foo&quot; in x</span>
        <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;foo&quot;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> x:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>

        <span class="hljs-comment"># (3) get current segment after last &quot;foo&quot;</span>
        bar_segment = x.rsplit(<span class="hljs-string">&quot;foo&quot;</span>,<span class="hljs-number">1</span>)[<span class="hljs-number">1</span>]
        
        <span class="hljs-comment"># 3(a) already satisfied</span>
        <span class="hljs-keyword">if</span> bar_segment.startswith(<span class="hljs-string">&quot; bar&quot;</span>):
            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>

        <span class="hljs-comment"># 3(b) force continuations to align with &quot; bar&quot;</span>
        <span class="hljs-keyword">return</span> fmap(
            (tset(<span class="hljs-string">&quot; bar&quot;</span>, regex=<span class="hljs-literal">True</span>), <span class="hljs-literal">True</span>), <span class="hljs-comment"># &quot; bar&quot; -&gt; True</span>
            (<span class="hljs-string">&quot;*&quot;</span>,          <span class="hljs-literal">False</span>) <span class="hljs-comment"># anything else -&gt; False</span>
        )

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">final</span>(<span class="hljs-params">self, x, result=<span class="hljs-literal">None</span>, **kwargs</span>):
        <span class="hljs-comment"># violations are definitive</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> result: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;fin&quot;</span>
        <span class="hljs-comment"># otherwise, depends on definitiveness of x</span>
        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;fin&quot;</span> <span class="hljs-keyword">if</span> x == <span class="hljs-string">&quot;fin&quot;</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;var&quot;</span>
</span></code></pre></div><p><strong>forward() implementation</strong>: First, we implement the <code>forward</code> method: To validate the <code>foo</code>-<code>bar</code> property, we check that any string segment following a potential <code>foo</code> substring aligns with <code>&quot; bar&quot;</code>. For this, we have to consider the case of x being none (not yet generated), a partial match (including empty strings), and a match that extends beyond <code>&quot; bar&quot;</code>. Depending on model tokenization <code>forward()</code> may be called on any such variation, and thus has to be able to handle all of them.</p><p><strong>follow() implementation</strong>: Next, we implement the <code>follow</code> method. For this, we again consider multiple cases:</p><ol><li><p>If <code>x</code> is not yet generated, we do not have to restrict the next token.</p></li><li><p>If there is no <code>foo</code> in <code>x</code>, we do not have to restrict the next token.</p></li><li><p>If there <em>is</em> a <code>foo</code> right at the end of <code>x</code>, we restrict as follows:</p><p><strong>(a)</strong> If the segment already starts with <code>&quot; bar&quot;</code>, no restrictions are necessary.</p><p><strong>(b)</strong> Otherwise, we restrict the next token to <code>&quot; bar&quot;</code>. For this, we construct a so-called <em>follow map</em>, a mapping of token ranges to the future evaluation result of our operator, if the next token is in the specified range.</p><p>In our <code>foo</code>-<code>bar</code> case it suffices to indicate that a continuation of <code> bar</code> evaluates to <code>True</code>, and any other continuation to <code>False</code>. This is achieved by the <code>fmap</code> function, which constructs a follow map from a list of token ranges and their respective future evaluation results. To construct token ranges the <a href="https://github.com/eth-sri/lmql/blob/main/src/lmql/ops/token_set.py#L535" target="_blank" rel="noreferrer"><code>tset</code> constructor</a> can be used, which allows to select tokens by length, set, prefix or regex, independent from the concrete tokenizer in use. In this case we use the <code>regex=True</code> option, to automatically select all tokens that fully or partially match <code>&quot; bar&quot;</code>.</p></li></ol><p><strong>final() implementation</strong>: Lastly, we implement the <code>final</code> method. This indicates to the LMQL runtime, whether a result of our custom operator is final with respect to the current model output or temporary. In this case, a return value of <code>False</code> can always be considered final (a definitive violation, warranting early termination). Otherwise, we have to consider the definitiveness of the current value of <code>x</code>. If <code>x</code> is final, then the result of our operator is also final. Otherwise, it is temporary, as a further continuation of <code>x</code> may still result in satisfying the constraint.</p><blockquote><p><strong>Note:</strong> For illustrative purposes, 3b of our <code>follow()</code> implementation simplifies an important detail about token alignment. It only consider the case, where <code>follow()</code> is called right at the end of <code>&quot;foo&quot;</code>, i.e. depending on model behavior and tokenization, <code>follow()</code> may also run on a partial result like <code>&quot;foo b&quot;</code>, where the correct follow map should indicate <code>&quot;ar&quot;</code> as valid continuation not the full <code>&quot; bar&quot;</code>. To handle this, one can simply rely on the implementation of built-in InOpStrInSet (implementation of constraint <code>VAR in [...]</code>), and replace the <code>fmap</code> call with <code>InOpStrInSet([]).follow(bar_segment, [&quot; bar&quot;])</code>, which will automatically handle all such cases.</p></blockquote><h3 id="using-the-custom-constraint-operator" tabindex="-1">Using the Custom Constraint Operator <a class="header-anchor" href="#using-the-custom-constraint-operator" aria-label="Permalink to &quot;Using the Custom Constraint Operator&quot;">​</a></h3><p>To use the custom constraint operator, you can simply import it in your query context and use it as follows:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="hljs"><code><span class="line"><span class="hljs-string">&quot;Say &#39;foo&#39;:<span class="hljs-placeholder">[A]</span>&quot;</span> <span class="hljs-keyword">where</span> foo_bar(A)
</span></code></pre></div><p>In general, you have to ensure that the <code>@LMQLOp</code> decorator is executed in your current process before the query is parsed, e.g. by importing the module containing the operator implementation.</p><h2 id="what-happens-under-the-hood" tabindex="-1">What Happens Under the Hood? <a class="header-anchor" href="#what-happens-under-the-hood" aria-label="Permalink to &quot;What Happens Under the Hood?&quot;">​</a></h2><p>Given an operator implementation as above, the LMQL runtime will be able to both validate model output during generation and derive token-level prediction masks. For this, <code>forward</code>, <code>follow</code> and <code>final</code> are called repeatedly during generation, with the current model output <code>x</code> as input. This allows the runtime to derive both validity of the current model output, as well as next-token ranges for which the operator definitively (<code>final</code>) evaluates to <code>False</code>. Based on the correctness of the underlying implementation, this soundly ensures that the model will never select a <code>follow</code>-masked token that would definitively violate your constraint.</p><h2 id="expressiveness-of-lmql-constraints" tabindex="-1">Expressiveness of LMQL Constraints <a class="header-anchor" href="#expressiveness-of-lmql-constraints" aria-label="Permalink to &quot;Expressiveness of LMQL Constraints&quot;">​</a></h2><p>LMQL constraints are applied eagerly during generation by relying on token masking. This means, that the model will not be able to generate any tokens that are masked by the constraints. However, naturally, this approach is limited with respects to expressiveness, since not all properties on text can be decided on a token-by-token basis. More specifically, expressiveness is limited to the validation of <a href="https://en.wikipedia.org/wiki/Context-free_grammar" target="_blank" rel="noreferrer">context-free languages</a>. To enable safe use of token masking, LMQL&#39;s implementation of final/follow semantics provide a soundness guarantee with respect to token masking (see <a href="https://arxiv.org/abs/2212.06094" target="_blank" rel="noreferrer">LMQL paper</a>).</p><p>Nonetheless, due to eager evaluation of constraints during generation, LMQL constraints will trigger as soon as the model output violates the constraint definitively (i.e. the validation result is final), preventing the model from the costly generation of invalid output. This is an advantage over validation in post-processing, where violations may only be detected after the model has already generated a large amount of invalid output.</p>`,28),l=[n];function r(i,c,p,d,h,u){return s(),a("div",null,l)}const g=e(t,[["render",r]]);export{f as __pageData,g as default};
