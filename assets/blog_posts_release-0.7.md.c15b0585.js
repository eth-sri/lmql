import{_ as s,o as n,c as o,Q as t,k as e,a}from"./chunks/framework.980cae92.js";const w=JSON.parse('{"title":"LMQL 0.7 brings Procedural Prompt Programming","description":"","frontmatter":{"date":"2023-10-10T10:10:00.000Z","title":"LMQL 0.7 brings Procedural Prompt Programming"},"headers":[],"relativePath":"blog/posts/release-0.7.md","filePath":"blog/posts/release-0.7.md"}'),r={name:"blog/posts/release-0.7.md"},l=t(`<h1 id="lmql-0-7-brings-procedural-prompt-programming" tabindex="-1">LMQL 0.7 brings Procedural Prompt Programming <a class="header-anchor" href="#lmql-0-7-brings-procedural-prompt-programming" aria-label="Permalink to &quot;LMQL 0.7 brings Procedural Prompt Programming&quot;">â€‹</a></h1><p><span class="date">October 10, 2023</span></p><p>Today, we are releasing LMQL 0.7. This series is the biggest update since the original release, including many community contributions. Next to several new main-line features like nested queries, the Generations API and the Chat API, it also includes several <em>experimental preview features</em>, allowing you to experiment with new incoming functionality before it is fully released.</p><p>LMQL 0.7 has also moved to <a href="https://semver.org" target="_blank" rel="noreferrer">semantic versioning</a> with the direct predecessor being 0.0.6.6. This means that the next feature release will be 0.8, and the next bugfix release will be 0.7.1.</p><h2 id="nested-queries-for-procedural-prompt-programming" tabindex="-1">Nested Queries for Procedural Prompt Programming <a class="header-anchor" href="#nested-queries-for-procedural-prompt-programming" aria-label="Permalink to &quot;Nested Queries for Procedural Prompt Programming&quot;">â€‹</a></h2><p>In 0.7, you can now use <a href="./../../docs/language/nestedqueries.html">Nested Queries</a> to call an LMQL query as a nested function in the context of another query. For this, LMQL implements procedural programming for prompting. To illustrate, consider the following example:</p><div class="language-lmql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">lmql</span><pre class="hljs"><code><span class="line"><span class="hljs-comment"># chain of thought prompting strategy</span>
<span class="hljs-meta">@lmql.query</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">chain_of_thought</span>():
    <span class="hljs-inline-lmql"><span class="inline-lmql-delim">&#39;&#39;&#39;lmql</span>
    <span class="hljs-string">&quot;A: Let&#39;s think step by step.\\n <span class="hljs-placeholder">[REASONING]</span>&quot;</span>
    <span class="hljs-string">&quot;Therefore the answer is<span class="hljs-placeholder">[ANSWER]</span>&quot;</span> <span class="hljs-keyword">where</span> STOPS_AT(ANSWER, <span class="hljs-string">&quot;.&quot;</span>)
    <span class="hljs-keyword">return</span> ANSWER.strip()
    <span class="inline-lmql-delim">&#39;&#39;&#39;</span></span>

<span class="hljs-comment"># top-level query</span>
<span class="hljs-string">&quot;Q: It is August 12th, 2020. What date was it \\
    100 days ago? <span class="hljs-placeholder">[ANSWER: chain_of_thought]</span>&quot;</span>

ANSWER <span class="hljs-comment"># May 4th, 2020</span>
</span></code></pre></div><p>We first define a simple LMQL function <code>chain_of_thought</code> to do <em>chain-of-thought prompting</em>. In our top-level query, we can then call this function to decode an answer using the <code>[ANSWER: chain_of_thought]</code> syntax. During execution, LMQL then inserts the instructions and constraints from <code>chain_of_thought</code> into the top-level query, generates a value for <code>ANSWER</code>, and then removes the instructions and constraints again, only returning the final result.</p><p><strong>Nested queries are Prompt Function Calls.</strong> This design of nested queries is inspired by the idea of <em>function or procedure calls</em> in traditional programming. Removing intermediate instructions and constraints also has parallels to the idea of <em>stack unwinding</em>, a technique to implement function calls in low-level languages.</p><p>LMQL transfers these ideas to prompting, inheriting the general benefits of procedural programming:</p><ul><li><p><strong>Encapsulation and Model Focus</strong> Nested Queries encapsulate and hide the prompting logic used to generate <code>ANSWER</code>, which means our top-level query is much cleaner and more concise. Further, by hiding intermediate instructions from the model in the context of the top-level query, we can reduce noise in the overall prompt, allowing the model to focus on the currently relevant information only, and not get distracted by previous intermediate steps.</p></li><li><p><strong>Nesting and Reuse</strong> LMQL queries can be nested arbitrarily deep, allowing you to reuse and combine queries modularly. For example, you could define a query <code>get_year</code> to extract a year from the response text, and then use this query in <code>chain_of_thought</code> to extract the date from the question. By achieving modularity for sub-prompts, nested queries also allow you to reuse prompts across different query programs.</p></li></ul><p>To learn more about nested queries, please refer to the <a href="./../../docs/language/nestedqueries.html">relevant chapter in the documentation</a>.</p><h2 id="generations-api" tabindex="-1">Generations API <a class="header-anchor" href="#generations-api" aria-label="Permalink to &quot;Generations API&quot;">â€‹</a></h2><p>LMQL 0.7 adds the <em>Generations API</em>, a lightweight high-level library for LMQL-based text generation and scoring. The API was designed to be easy to use and does not require users to write any LMQL themselves:</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="hljs"><code><span class="line"><span class="hljs-comment"># obtain a model instance</span>
m: lmql.LLM = lmql.model(<span class="hljs-string">&quot;openai/gpt-3.5-turbo-instruct&quot;</span>)
<span class="hljs-comment"># simple generation</span>
m.generate_sync(<span class="hljs-string">&quot;Hello&quot;</span>, max_tokens=<span class="hljs-number">10</span>)
<span class="hljs-comment"># -&gt; Hello, I am a 23 year old female.</span>
</span></code></pre></div><br><p>Functions such as <a href="./../../docs/lib/generations.html#llm-generate"><code>LLM.generate</code></a> and <a href="./../../docs/lib/generations.html#llm-score"><code>LLM.score</code></a> allow you to generate and score text using any LMQL-support inference backend. The Generations API is also seamlessly compatible with standard LMQL, allowing you to switch and combine the two as needed.</p><p>For more information, please refer to the <a href="./../../docs/lib/generations.html">documentation</a>.</p><h2 id="chat" tabindex="-1">Chat <a class="header-anchor" href="#chat" aria-label="Permalink to &quot;Chat&quot;">â€‹</a></h2><p>LMQL 0.7 adds a new <a href="./../../docs/lib/chat.html">Chat API</a>, allowing you to easily deploy chatbots with just a couple lines of LMQL.</p><img style="max-width:80vw;width:400pt;display:block;margin:auto;" src="https://github.com/eth-sri/lmql/assets/17903049/3f24b964-b9b6-4c50-acaa-b38e54554506"><p>LMQL Chat comes with custom output writers, that allow you to easily stream chatbot input and output over a variety of channels, including WebSockets, HTTP, and SSE. A simple <code>lmql chat</code> CLI tool was also added, that allows you to instantly launch your LMQL queries as fully interactive chatbots.</p><p>We also provide documentation resources on how to get started with chatbot development with LMQL, including chapters on Chatbot Serving, Internal Reasoning and Defending against Prompt Injection. For more information, please refer to the <a href="./../../docs/lib/chat.html">documentation</a>.</p><h2 id="backends" tabindex="-1">Backends <a class="header-anchor" href="#backends" aria-label="Permalink to &quot;Backends&quot;">â€‹</a></h2><p>LMQL 0.7 ships with three new backends for inference and tokenization:</p><ul><li><p>LMQL 0.7 adds support for OpenAI&#39;s newly released <code>gpt-3.5-turbo-instruct</code> model. In contrast to other 3.5 series models, this variant supports the <em>Completions API</em>, which means that LMQL constraints are compatible with it.</p></li><li><p>LMQL now supports hosting models on <a href="https://replicate.com" target="_blank" rel="noreferrer">replicate.com</a> infrastructure, allowing you to run LMQL models in the cloud. To learn more, please refer to the <a href="./../../docs/models/replicate.html">documentation</a>. Thanks a lot to community member <a href="https://github.com/charles-dyfis-net" target="_blank" rel="noreferrer">@charles-dyfis-net</a> for contributing this!</p></li><li><p>LMQL added <code>sentencepiece</code> as an additional tokenization backend, specifically for <code>llama.cpp</code> models. This means, <code>llama.cpp</code> models can now be used without requiring <code>transformers</code> for tokenization. Thanks a lot to community member <a href="https://github.com/khushChopra" target="_blank" rel="noreferrer">@khushChopra</a> for contributing this.</p></li></ul><h2 id="inference-certificates" tabindex="-1">Inference Certificates <a class="header-anchor" href="#inference-certificates" aria-label="Permalink to &quot;Inference Certificates&quot;">â€‹</a></h2><p>To make LLM inference more transparent and re-producible, LMQL 0.7 also adds <a href="./../../docs/lib/inference-certificates.html"><em>inference certificates</em></a>. An inference certificate is a simple data structure that records essential information needed to reproduce an inference result. Certificates can be generated for any LLM call that happens in an LMQL context.</p><p>To produce an inference certificate, pass <code>certificate=True</code> or <code>certificate=&lt;filename&gt;</code> to your query or generate call:</p><div class="language-truncated vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">truncated</span><pre class="hljs"><code><span class="line"><span class="hljs-comment"># call and save certificate</span>
say_hello(certificate=<span class="hljs-string">&quot;my-certificate.json&quot;</span>)
</span></code></pre></div><p>The resulting certificate file provides a way to document, trace and reproduce LLM inference results by recording the <em>exact (tokenized) prompts</em> and information on the <em>environment and generation parameters</em>.</p><p>This can be helpful to better understand what is happening during inference, to debug issues, and to reproduce results. It also offers a way to document LLM failures, to better guide the discussion around the concrete capabilities and limitations of LLMs.</p><h2 id="decorators" tabindex="-1">Decorators <a class="header-anchor" href="#decorators" aria-label="Permalink to &quot;Decorators&quot;">â€‹</a></h2><p><a href="./../../docs/language/decorators.html">Variable Decorators</a> offer a new and simple way to call custom Python functions as part of the core generation loop in LMQL:</p><div class="language-lmql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">lmql</span><pre class="hljs"><code><span class="line"><span class="hljs-keyword">def</span> <span class="hljs-title function_">screaming</span>(<span class="hljs-params">value</span>):
    <span class="hljs-string">&quot;&quot;&quot;Decorator to convert a string to uppercase&quot;&quot;&quot;</span>
    <span class="hljs-keyword">return</span> value.upper()

<span class="hljs-string">&quot;Say &#39;this is a test&#39;:<span class="hljs-placeholder">[@screaming TEST]</span>&quot;</span>
</span></code></pre></div>`,35),i=e("div",{class:"language-promptdown vp-adaptive-theme"},[e("button",{title:"Copy Code",class:"copy"}),e("span",{class:"lang"},"promptdown"),e("pre",{"pd-text":`Say 'this is a test': [TEST| THIS IS A TEST]
`,animate:"true",__animate:"true","animate-speed":"50",class:"promptdown promptdown-compiled",style:{opacity:"1"}},[e("p",{"pd-shadow-id":"52",text:"S","pd-insertion-point":"true"},[a("Say 'this is a test': "),e("span",{"pd-shadow-id":"54","pd-instant":"false",text:"",class:"promptdown-var color-pink"},[e("span",{"pd-shadow-id":"55",text:"T",class:"promptdown-var-name"},"TEST"),a(" THIS IS A TEST")]),a(`
`)])])],-1),c=t(`<p>Similar to Python decorators, LMQL decorators are functions that take a variable as input and can wrap and modify its value.</p><p>In the example above, we use the <code>@screaming</code> decorator to convert the value of <code>TEST</code> to uppercase. Decorators can be used to implement a wide range of custom functionality, including string normalization, datatype conversion, and more. LMQL also provides decorators that allow to stream or pre-process data during generation. For more information, please refer to the <a href="./../../docs/language/decorators.html">documentation</a>.</p><h2 id="documentation-update" tabindex="-1">Documentation Update <a class="header-anchor" href="#documentation-update" aria-label="Permalink to &quot;Documentation Update&quot;">â€‹</a></h2><p>The website and many chapters of the LMQL documentation have also been updated and extended and now include more examples and explanations. We have updated the visual design to make it easier to read and navigate.</p><p>The documentation now also includes a <em>work-in-progress</em> <a href="/docs/language/reference.html">Language Reference</a>, which aims to provide a more comprehensive and formal description of LMQL&#39;s syntax and semantics, all in one place.</p><h2 id="preview-features" tabindex="-1">Preview Features <a class="header-anchor" href="#preview-features" aria-label="Permalink to &quot;Preview Features&quot;">â€‹</a></h2><p>Apart from many new core features, LMQL 0.7 also ships with several <em>experimental preview features</em>, allowing you to test drive new functionality before it has fully stabilized and is released as main-line functionality.</p><p>These features are marked as <em>experimental</em> and are not yet fully supported. We are releasing them to gather feedback and to allow users to test them out early on. Note that these features are subject to change and may be removed/modified in future releases.</p><h3 id="lmql-actions-preview" tabindex="-1">LMQL Actions <span class="beta badge">Preview</span> <a class="header-anchor" href="#lmql-actions-preview" aria-label="Permalink to &quot;LMQL Actions &lt;span class=&quot;beta badge&quot;&gt;Preview&lt;/span&gt;&quot;">â€‹</a></h3><p><em>LMQL Actions</em> is the first version of LMQL&#39;s function calling layer. It allows you to expose arbitrary Python functions to the LLM reasoning loop and lets the model call them during generation. Function demonstration and the calling protocol can be both handled automatically by the LMQL runtime, allowing for simple use like this:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="hljs"><code><span class="line"><span class="hljs-keyword">def</span> <span class="hljs-title function_">wiki</span>(<span class="hljs-params">q</span>): ...
<span class="hljs-keyword">def</span> <span class="hljs-title function_">calc</span>(<span class="hljs-params">expr</span>): ...

<span class="hljs-string">&quot;Q: What is the population of the US and Germany combined?&quot;</span>
<span class="hljs-string">&quot;A: <span class="hljs-placeholder">[REASONING]</span>&quot;</span> <span class="hljs-keyword">where</span> inline_use(REASONING, [wiki, calc])
</span></code></pre></div><p>A future release will bring more documentation and details on Actions, including how to use and customize it for your use cases. Until then we invite everyone to try and hack with the current implementation, fully contained in <a href="https://github.com/eth-sri/lmql/blob/main/src/lmql/lib/actions.py" target="_blank" rel="noreferrer"><code>actions.py</code></a>.</p><h3 id="regex-constraints-preview" tabindex="-1">Regex Constraints <span class="beta badge">Preview</span> <a class="header-anchor" href="#regex-constraints-preview" aria-label="Permalink to &quot;Regex Constraints &lt;span class=&quot;beta badge&quot;&gt;Preview&lt;/span&gt;&quot;">â€‹</a></h3><p>LMQL now has support for regex constraints, allowing you to use regular expressions to constrain the output of a variable. For example, the following query will always generate a valid date of the form <code>DD/MM</code>:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="hljs"><code><span class="line"><span class="hljs-string">&quot;It&#39;s the last day of June so today is <span class="hljs-placeholder">[RESPONSE]</span>&quot;</span> <span class="hljs-keyword">where</span> REGEX(RESPONSE, r<span class="hljs-string">&quot;<span class="hljs-placeholder">[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]</span><span class="hljs-subst">{<span class="hljs-number">2</span>}</span>/<span class="hljs-placeholder">[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]</span><span class="hljs-subst">{<span class="hljs-number">2</span>}</span>&quot;</span>)
</span></code></pre></div><h3 id="types-datatype-constraints-preview" tabindex="-1">Types / Datatype Constraints <span class="beta badge">Preview</span> <a class="header-anchor" href="#types-datatype-constraints-preview" aria-label="Permalink to &quot;Types / Datatype Constraints &lt;span class=&quot;beta badge&quot;&gt;Preview&lt;/span&gt;&quot;">â€‹</a></h3><p>LMQL is moving towards fully typed LLM generation. On the way there, we have started to add support for <em>dataclass constraints</em>, allowing you to constrain the output of a variable to a specific structured output schema:</p><div class="language-lmql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">lmql</span><pre class="hljs"><code><span class="line"><span class="hljs-keyword">import</span> lmql
<span class="hljs-keyword">from</span> dataclasses <span class="hljs-keyword">import</span> dataclass

<span class="hljs-meta">@dataclass</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>:
    name: <span class="hljs-built_in">str</span>
    age: <span class="hljs-built_in">int</span>
    job: <span class="hljs-built_in">str</span>

<span class="hljs-string">&quot;Alice is a 21 years old and works as an engineer at LMQL Inc in Zurich, Switzerland.\\n&quot;</span>
<span class="hljs-string">&quot;Structured: <span class="hljs-placeholder">[PERSON_DATA]</span>\\n&quot;</span> <span class="hljs-keyword">where</span> <span class="hljs-built_in">type</span>(PERSON_DATA) <span class="hljs-keyword">is</span> Person

PERSON_DATA
<span class="hljs-comment"># Person(name=&#39;Alice&#39;, age=21, job=&#39;engineer&#39;)</span>
</span></code></pre></div><p>To achieve this, LMQL leverages constrained generation to make sure the LLM always produces all information required to populate a valid <code>Person</code> object. The resulting <code>PERSON_DATA</code> object can then be directly used like a regular Python object. Types are still in an early stage and we are working on adding more features and functionality.</p><h2 id="other-changes" tabindex="-1">Other Changes <a class="header-anchor" href="#other-changes" aria-label="Permalink to &quot;Other Changes&quot;">â€‹</a></h2><ul><li><p>The LMQL playground can now be used from the Windows <code>cmd.exe</code>. Thanks a lot to community member <a href="https://github.com/mosheduminer" target="_blank" rel="noreferrer">@mosheduminer</a>.</p></li><li><p>LMQL/LMTP model backends can now be accessed <a href="https://github.com/eth-sri/lmql/blob/main/src/lmql/models/lmtp/lmtp_langchain.py" target="_blank" rel="noreferrer">as Langchain <code>LLM</code> objects</a> to use them in your Langchain pipelines. Thanks to <a href="https://github.com/4onon" target="_blank" rel="noreferrer">@4onon</a> for contributing this.</p></li><li><p>LMQL can now be <a href="https://github.com/eth-sri/lmql/tree/main/scripts/flake.d" target="_blank" rel="noreferrer">installed as a NixOS package</a>. Thanks to <a href="https://github.com/charles-dyfis-net" target="_blank" rel="noreferrer">@charles-dyfis-net</a> for contributing this.</p></li></ul><h2 id="ðŸŽ¬-and-that-s-a-wrap" tabindex="-1">ðŸŽ¬ And that&#39;s a wrap! <a class="header-anchor" href="#ðŸŽ¬-and-that-s-a-wrap" aria-label="Permalink to &quot;ðŸŽ¬ And that&#39;s a wrap!&quot;">â€‹</a></h2><p>LMQL 0.7 is a big release and we are excited to see what you will build with it. As always, please let us know if you have any questions, suggestions or bug reports, on <a href="https://github.com/eth-sri/lmql" target="_blank" rel="noreferrer">GitHub</a>, <a href="https://discord.gg/7eJP4fcyNT" target="_blank" rel="noreferrer">Discord</a>, <a href="https://twitter.com/lmqllang" target="_blank" rel="noreferrer">Twitter</a> or via <a href="mailto:hello@lmql.ai" target="_blank" rel="noreferrer">hello@lmql.ai</a>.</p>`,23),p=[l,i,c];function d(h,u,m,g,f,b){return n(),o("div",null,p)}const q=s(r,[["render",d]]);export{w as __pageData,q as default};
