import{_ as e,o as s,c as a,Q as n}from"./chunks/framework.c2adf1ba.js";const g=JSON.parse('{"title":"Python Integration","description":"","frontmatter":{"outline":[2,3]},"headers":[],"relativePath":"docs/lib/python.md","filePath":"docs/lib/python.md"}'),t={name:"docs/lib/python.md"},l=n(`<h1 id="python-integration" tabindex="-1">Python Integration <a class="header-anchor" href="#python-integration" aria-label="Permalink to &quot;Python Integration&quot;">​</a></h1><div class="subtitle">Use LMQL from Python.</div><p>The primary way to use LMQL from your existing application is the <code>lmql</code> Python package.</p><p>The <code>lmql</code> package offers a number of functions that allow you to define and run LMQL programs, directly from within Python.</p><h2 id="query-functions" tabindex="-1">Query Functions <a class="header-anchor" href="#query-functions" aria-label="Permalink to &quot;Query Functions&quot;">​</a></h2><p>In Python, a piece of LMQL code is represented as a standard Python function. This means, you can define, parameterize and call LMQL code, directly from within your existing Python application.</p><p>To enable this, LMQL offers three entry points:</p><ul><li><p>An <code>@lmql.query</code> decorator, to define LMQL query functions using standard <code>def</code> syntax, including support for capturing and accessing the surrounding Python scope.</p></li><li><p>An <code>lmql.run</code> function, to directly run a string of LMQL code as a query, without having to define a function first.</p></li><li><p><code>lmql.F(...)</code> to evaluate pieces of LMQL code as pure lambda expressions, very similar to Python&#39;s <code>lambda</code> keyword.</p></li></ul><p>All three methods internally construct an LMQL query function for the provided code. This chapter first discusses, how to define and run query functions using <code>lmql.query</code>, <code>lmql.run</code> and <code>lmql.F</code>, and then provides information on the <a href="#query-results">query result format</a> and how to <a href="#query-configuration">configure queries</a>, e.g. to specify model, decoder and other parameters.</p><h3 id="lmql-query" tabindex="-1"><code>lmql.query</code> <a class="header-anchor" href="#lmql-query" aria-label="Permalink to &quot;\`lmql.query\`&quot;">​</a></h3><p>The <code>@lmql.query</code> decorator allows you to directly expose a piece of LMQL code as a Python function, and call it from your existing code:</p><div class="language-lmql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">lmql</span><pre class="hljs"><code><span class="line"><span class="hljs-meta">@lmql.query</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">chain_of_thought</span>(<span class="hljs-params">question</span>):
    <span class="hljs-inline-lmql"><span class="inline-lmql-delim">&#39;&#39;&#39;lmql</span>
    <span class="hljs-comment"># Q&amp;A prompt template</span>
    <span class="hljs-string">&quot;Q: <span class="hljs-subst">{question}</span>\\n&quot;</span>
    <span class="hljs-string">&quot;A: Let&#39;s think step by step.\\n&quot;</span>
    <span class="hljs-string">&quot;<span class="hljs-placeholder">[REASONING]</span>&quot;</span>
    <span class="hljs-string">&quot;Thus, the answer is:<span class="hljs-placeholder">[ANSWER]</span>.&quot;</span>

    <span class="hljs-comment"># return just the ANSWER to the caller</span>
    <span class="hljs-keyword">return</span> ANSWER
    <span class="inline-lmql-delim">&#39;&#39;&#39;</span></span>

<span class="hljs-built_in">print</span>(chain_of_thought(<span class="hljs-string">&#39;Today is the 12th of June, what day was it 1 week ago?&#39;</span>))
</span></code></pre></div><div class="language-output vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">output</span><pre class="hljs"><code><span class="line">5th of June.
</span></code></pre></div><p>Note that the actual LMQL program is defined in the docstring of the function, allowing LMQL code to embed seamlessly.</p><p>Function arguments can be passed freely into the LMQL, and the return value of the function is passed back to the caller.</p><p>Variables from the surrounding context can also be captured by the query program, enabling access to the full power of Python from within LMQL.</p><div class="info custom-block"><p class="custom-block-title">Jupyter Notebooks</p><p>You may encounter problems with the <code>@lmql.query</code> decorator in a Jupyter Notebook, because notebook environments are asynchronous, by default. To work around this, you can declare your query functions as <code>async</code> and use the <code>await</code> keyword when calling them.</p><p>Alternatively, you can install the <a href="https://pypi.org/project/nest-asyncio/" target="_blank" rel="noreferrer"><code>nest_asyncio</code></a> package and call <code>nest_asyncio.apply()</code>, to enable nested event loops in your notebook.</p></div><h4 id="variable-capturing" tabindex="-1">Variable Capturing <a class="header-anchor" href="#variable-capturing" aria-label="Permalink to &quot;Variable Capturing&quot;">​</a></h4><p>The <code>@lmql.query</code> decorator also allows you to access variables from the surrounding context, and make them available to the query program. This is done automatically by capturing the function&#39;s closure at definition time:</p><div class="language-lmql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">lmql</span><pre class="hljs"><code><span class="line"><span class="hljs-keyword">import</span> re

a = <span class="hljs-number">12</span>

<span class="hljs-meta">@lmql.query</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">query</span>():
    <span class="hljs-inline-lmql"><span class="inline-lmql-delim">&#39;&#39;&#39;lmql</span>
    <span class="hljs-comment"># access &#39;a&#39; from the global namespace</span>
    <span class="hljs-string">&quot;Tell me a fun fact about <span class="hljs-subst">{a}</span>: <span class="hljs-placeholder">[FACT]</span>&quot;</span>
    <span class="hljs-comment"># use imported &#39;re&#39; module</span>
    <span class="hljs-keyword">return</span> re.sub(r<span class="hljs-string">&#39;\\d+&#39;</span>, <span class="hljs-string">&#39;<span class="hljs-placeholder">[NUMBER]</span>&#39;</span>, FACT)
    <span class="inline-lmql-delim">&#39;&#39;&#39;</span></span>

<span class="hljs-built_in">print</span>(query())
</span></code></pre></div><div class="language-output vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">output</span><pre class="hljs"><code><span class="line">[NUMBER] <span class="hljs-keyword">is</span> the smallest number <span class="hljs-keyword">with</span> exactly six divisors ([NUMBER], [NUMBER], [NUMBER], [NUMBER], [NUMBER], [NUMBER]).
</span></code></pre></div><p>As shown, within an <code>@lmql.query</code> function we have full access to the surrounding context, including any variables and imports defined in the outer scope. This allows for flexible integration of LMQL into your existing codebase.</p><h3 id="lmql-run" tabindex="-1"><code>lmql.run</code> <a class="header-anchor" href="#lmql-run" aria-label="Permalink to &quot;\`lmql.run\`&quot;">​</a></h3><p>To run a string of LMQL code directly, without having to define a function first, you can use the <code>lmql.run</code> function:</p><div class="language-lmql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">lmql</span><pre class="hljs"><code><span class="line">query_string = <span class="hljs-string">&quot;&quot;&quot;
    &quot;Q: <span class="hljs-subst">{question}</span>\\\\n&quot;
    &quot;A: Let&#39;s think step by step.\\\\n&quot;
    &quot;<span class="hljs-placeholder">[ANSWER]</span>&quot;
&quot;&quot;&quot;</span>

<span class="hljs-keyword">await</span> lmql.run(query_string, question=<span class="hljs-string">&quot;What is 2x3?&quot;</span>)
</span></code></pre></div><p>Note that with <code>lmql.run</code>, newline characters <code>\\n</code> has to be a escaped as <code>\\\\n</code> in the query string, to avoid syntax errors.</p><p>To run synchronously, without <code>await</code>, you can use the <code>lmql.run_sync</code> function instead.</p><div class="tip custom-block"><p class="custom-block-title">Escaping LMQL-specific Control Characters</p><p>When constructing queries from strings directly, always make sure to <a href="./../language/scripted-prompting.html#escaping">escape LMQL-specific control characters correctly</a>, to avoid syntax errors in the resulting query program.</p></div><h4 id="precompiling-queries" tabindex="-1">Precompiling Queries <a class="header-anchor" href="#precompiling-queries" aria-label="Permalink to &quot;Precompiling Queries&quot;">​</a></h4><p>When using <code>lmql.run</code>, the query string will be compiled into a query function on every call. To avoid this, you can use the <code>lmql.query</code> function with a string, to create a function that will be compiled only once and can then be called multiple times:</p><div class="language-lmql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">lmql</span><pre class="hljs"><code><span class="line">chain_of_thought = lmql.query(<span class="hljs-string">&quot;&quot;&quot;
    &quot;Q: <span class="hljs-subst">{question}</span>\\\\n&quot;
    &quot;A: Let&#39;s think step by step.\\\\n&quot;
    &quot;<span class="hljs-placeholder">[ANSWER]</span>&quot;
&quot;&quot;&quot;</span>, is_async=<span class="hljs-literal">False</span>)

chain_of_thought(<span class="hljs-string">&quot;What is 2x3?&quot;</span>)
</span></code></pre></div><p>Here, setting <code>is_async=False</code> ensures that the query can be executed synchronously.</p><h3 id="lmql-f" tabindex="-1"><code>lmql.F</code> <a class="header-anchor" href="#lmql-f" aria-label="Permalink to &quot;\`lmql.F\`&quot;">​</a></h3><p>Lastly, <code>lmql.F</code> offers a lightweight way to evaluate pieces of LMQL code as simple lambda expressions, very similar to Python&#39;s <code>lambda</code> keyword.</p><p>This offers a lightweight entryway to get started with integrating small LLM-based utilities in your code, without having to write a full LMQL program:</p><div class="language-lmql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">lmql</span><pre class="hljs"><code><span class="line">summarize = lmql.F(<span class="hljs-string">&quot;Summarize the following in a \\
                   few words: <span class="hljs-subst">{data}</span>: <span class="hljs-placeholder">[SUMMARY]</span>&quot;</span>)

main_subject = lmql.F(<span class="hljs-string">&quot;What is the main subject (noun) \\
                       of the following text? <span class="hljs-subst">{data}</span>: <span class="hljs-placeholder">[SUBJECT]</span>&quot;</span>, 
                      <span class="hljs-string">&quot;len(TOKENS(SUBJECT)) &lt; 20&quot;</span>)

text = <span class="hljs-string">&quot;LMQL generalizes natural language prompting, ...&quot;</span>

summarize(data=text) <span class="hljs-comment"># LMQL improves natural language prompting with </span>
<span class="hljs-comment"># Python and fixed answer templates for better control over LLMs.</span>

main_subject(data=text) <span class="hljs-comment"># LMQL</span>

</span></code></pre></div><p>Syntactically, an <code>lmql.F</code> expressions corresponds to a single <a href="./../language/scripted-prompting.html">LMQL prompt statement</a>, without the <code>&quot;</code> quotes. The <code>lmql.F</code> function returns a callable object, which can be used like a regular query function.</p><p><strong>Return Value</strong> If the <code>lmql.F</code> contains only one placeholder variable, its generated value will be used as the return value of the function. Otherwise, a dictionary of all placeholder values will be returned.</p><p><strong>Constraints</strong> To specify constraints in an <code>lmql.F</code> expression, you can pass a <code>constraints=...</code> string argument, which will be parsed and enforced like a <code>where</code> clause in a regular LMQL prompt statement.</p><h2 id="query-results" tabindex="-1">Query Results <a class="header-anchor" href="#query-results" aria-label="Permalink to &quot;Query Results&quot;">​</a></h2><p>In general, the result of query function is determined the use of <code>return</code> statements and the decoding algorithm used to execute the query:</p><h3 id="query-functions-with-return-statements" tabindex="-1">Query Functions With <code>return</code> statements <a class="header-anchor" href="#query-functions-with-return-statements" aria-label="Permalink to &quot;Query Functions With \`return\` statements&quot;">​</a></h3><p>Query functions with <code>return</code> statements will return the value of the <code>return</code> statement. If a decoding algorithm with multiple output sequences is used (e.g. <code>sample(n=2)</code>), the return value will be a list of all <code>return</code> values.</p><div class="language-lmql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">lmql</span><pre class="hljs"><code><span class="line">number = lmql.F(<span class="hljs-string">&quot;A random number: <span class="hljs-placeholder">[JOKE: <span class="hljs-built_in">int</span>]</span>&quot;</span>)

<span class="hljs-comment"># sample two results</span>
number(decoder=<span class="hljs-string">&quot;sample&quot;</span>, n=<span class="hljs-number">2</span>)
</span></code></pre></div><div class="language-result vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">result</span><pre class="hljs"><code><span class="line">[1, 25]
</span></code></pre></div><h3 id="query-functions-without-return-statements" tabindex="-1">Query Functions Without <code>return</code> statements <a class="header-anchor" href="#query-functions-without-return-statements" aria-label="Permalink to &quot;Query Functions Without \`return\` statements&quot;">​</a></h3><p>If no <code>return</code> statement is specified, the return value of the query function is a designated <code>lmql.LMQLResult</code> object, which contains the last assigned value of all variables defined in the query program:</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="hljs"><code><span class="line"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LMQLResult</span>:
    <span class="hljs-comment"># full prompt with all variables substituted</span>
    prompt: <span class="hljs-built_in">str</span>
    <span class="hljs-comment"># a dictionary of all assigned template variable values</span>
    variables: <span class="hljs-type">Dict</span>[<span class="hljs-built_in">str</span>, <span class="hljs-built_in">str</span>]
</span></code></pre></div><p>This allows to inspect the full query prompt, as well as individual variable values, after query execution:</p><div class="language-lmql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">lmql</span><pre class="hljs"><code><span class="line">joke = lmql.query(<span class="hljs-string">&quot;&quot;&quot;
    &quot;Q: Tell me a joke about plants\\\\n&quot;
    &quot;A: <span class="hljs-placeholder">[JOKE]</span>&quot;               
&quot;&quot;&quot;</span>, is_async=<span class="hljs-literal">False</span>)

joke()
</span></code></pre></div><div class="language-result vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">result</span><pre class="hljs"><code><span class="line">LMQLResult(prompt=<span class="hljs-string">&#39;Q: Tell me a joke about plants\\nA: Why did the tomato turn red?\\n\\nBecause it saw the salad dressing!&#39;</span>, variables={<span class="hljs-string">&#39;JOKE&#39;</span>: <span class="hljs-string">&#39;Why did the tomato turn red?\\n\\nBecause it saw the salad dressing!&#39;</span>}, distribution_variable=<span class="hljs-literal">None</span>, distribution_values=<span class="hljs-literal">None</span>)
</span></code></pre></div><p>If a decoding algorithm with multiple output sequences is used (e.g. <code>sample(n=2)</code>), the return value will be a list of all such <code>LMQLResult</code> objects.</p><h2 id="query-configuration" tabindex="-1">Query Configuration <a class="header-anchor" href="#query-configuration" aria-label="Permalink to &quot;Query Configuration&quot;">​</a></h2><p>To further control query execution (e.g. set the model, decoder, etc.), you can provide additional configuration parameters to any <code>lmql.query</code>, <code>lmql.run</code> or <code>lmql.F</code> call:</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="hljs"><code><span class="line"><span class="hljs-meta">@lmql.query(<span class="hljs-params">model=lmql.model(<span class="hljs-params"><span class="hljs-string">&quot;chatgpt&quot;</span></span>), decoder=<span class="hljs-string">&quot;argmax&quot;</span></span>)</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">chain_of_thought</span>(<span class="hljs-params">question</span>):
    ...
</span></code></pre></div><p>For this, the following arguments are supported:</p><ul><li><p><code>model=&lt;MODEL&gt;</code> - The model to use for the query. This overrides the model specified in the query program. You can pass a model identifier or an <a href="./../../docs/models/#loading-models"><code>lmql.model</code></a> object.</p></li><li><p><code>decoder=&lt;DECODER&gt;</code> - The decoder to use for the query. This overrides any decoder specified by the query program. You can pass a any supported <a href="./../../docs/language/decoding.html">decoder identifier</a>.</p></li><li><p><code>output_writer=&lt;OUTPUT_WRITER&gt;</code> - The output writer to use for streaming query progress during execution, see <a href="./output.html">Output Streaming</a> for details. Defaults to <code>None</code>.</p></li><li><p><code>verbose=&lt;True|False&gt;</code> - Whether to print verbose logging output during query execution (API requests, LLM inference parameters, etc.). Defaults to <code>False</code>.</p></li><li><p><code>certificate=&lt;True|False&gt;</code> - Whether to produce an <a href="./../../docs/lib/inference-certificates.html">inference certificate</a> for the execution of a query. Defaults to <code>False</code>.</p></li><li><p><code>**kwargs</code> - Any extra keyword arguments are passed to the <a href="./../../docs/language/decoding.html">decoding algorithm</a>. See <a href="./../../docs/language/decoding.html#other-decoding-parameters">other decoding parameters</a> for more details on the available parameters.</p></li></ul><p><strong>Overriding Defaults</strong> To override these configuration parameters at call time, you can also pass them as additional keyword arguments to the query function call:</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="hljs"><code><span class="line"><span class="hljs-comment"># executes &#39;chain_of_thought&#39; with the &#39;gpt2-xl&#39; model</span>
chain_of_thought(<span class="hljs-string">&quot;What is the meaning of life?&quot;</span>, 
                 model=<span class="hljs-string">&quot;gpt2-xl&quot;</span>, temperature=<span class="hljs-number">0.5</span>)
</span></code></pre></div><p>The result object is a dataclass with the following fields:</p><div class="language-python vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="hljs"><code><span class="line"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LMQLResult</span>:
    <span class="hljs-comment"># full prompt with all variables substituted</span>
    prompt: <span class="hljs-built_in">str</span>
    <span class="hljs-comment"># a dictionary of all assigned template variable values</span>
    variables: <span class="hljs-type">Dict</span>[<span class="hljs-built_in">str</span>, <span class="hljs-built_in">str</span>]
</span></code></pre></div>`,61),o=[l];function i(r,c,p,u,d,h){return s(),a("div",null,o)}const y=e(t,[["render",i]]);export{g as __pageData,y as default};
